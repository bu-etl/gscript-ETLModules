VERSION v2.2
CLEARLOG
LOADCONFIG
LOADCONFIG "" Scripts\ETLModules\ThroughPut\TP_Config.txt

SETLOG "TP_Module_Data.txt"

COPY $bot_chuck_num 3
#GETINTPOPUP $bot_pos_num "Which module PCB position are you using?"
COPY $top_chuck_num 4

SETVAC "etl_chuck_{$bot_chuck_num}" 1  # vacuum for assembly plate
CALL @MAKE_MODULE 1 $bot_chuck_num $top_chuck_num 1
SETVAC "etl_chuck_{$bot_chuck_num}" 0  # vacuum for assembly plate

END


@MAKE_MODULE(bot_pos_num,bot_chuck_num,top_chuck_num,print_results)
#Arguments
#    bot_pos_num = position number of the Module PCB, we infer the ETROC+LGAD subassembly positions from this number
#    bot_chuck_num = chuck number of the Module PCB
#    top_chuck_num = chuck number of ETROC+LGAD subasssemblies
#    print_results = 0 for dont get placement data and 1 to get placement data

# We assume that assembly on Module PCB position 1 will use ETROC+LGAD subassemblies
# on position 1, 5, 9, and 13 (ie row 1), while Module PCB position 2 will use 
# positions 2, 6, 10, and 14, and so on for Module PCB position 3 and 4
    COPY $topA_pos_num $bot_pos_num
    COPY $topB_pos_num `$bot_pos_num+4`
    COPY $topC_pos_num `$bot_pos_num+8`
    COPY $topD_pos_num `$bot_pos_num+12`
    COPY $top_thickness {0,0,0.6} #get new thickness of throughput sub assembly
    HOME if-needed
    #set vaccuums
    SETVAC "etl_chuck_{$top_chuck_num}_pos_{$topA_pos_num}" 1 #for top piece A
    SETVAC "etl_chuck_{$top_chuck_num}_pos_{$topB_pos_num}" 1 #for top piece B
    SETVAC "etl_chuck_{$top_chuck_num}_pos_{$topC_pos_num}" 1 #for top piece C
    SETVAC "etl_chuck_{$top_chuck_num}_pos_{$topD_pos_num}" 1 #for top piece D
    

    #Survey Module PCB
    MOVENAME "etl_chuck_{$bot_chuck_num}"
    CALL @SURVEY_PART $bot_chuck_num $bot_pos_num 1 0 -> $bot_pos $bot_rot
    MOVENAME "etl_chuck_{$bot_chuck_num}"

    #Survey all 4 ETROC - Sensor PCB Sub Assemblies
    MOVENAME "etl_chuck_{$top_chuck_num}"
    CALL @SURVEY_PART $top_chuck_num $topA_pos_num 2 1 -> $topA_pos $topA_rot
    CALL @SURVEY_PART $top_chuck_num $topB_pos_num 2 1 -> $topB_pos $topB_rot
    CALL @SURVEY_PART $top_chuck_num $topC_pos_num 2 1 -> $topC_pos $topC_rot
    CALL @SURVEY_PART $top_chuck_num $topD_pos_num 2 1 -> $topD_pos $topD_rot
    MOVENAME "etl_chuck_{$top_chuck_num}"

    #survey the LGAD, NOT IMPLEMENTED FOR FUNCTION DEF NEEDS UPDATE DONT UNCOMMENT NOW
    #CALL @SURVEY_LGAD $top_chuck_num $topA_pos_num 2 -> $LGAD_A_pos $LGAD_A_rot
    #CALL @SURVEY_LGAD $top_chuck_num $topB_pos_num 2 -> $LGAD_B_pos $LGAD_B_rot
    #CALL @SURVEY_LGAD $top_chuck_num $topC_pos_num 2 -> $LGAD_C_pos $LGAD_C_rot
    #CALL @SURVEY_LGAD $top_chuck_num $topD_pos_num 2 -> $LGAD_D_pos $LGAD_D_rot
    
    #CALL @PRINT_SURVEY_RESULTS $topA_pos $topA_rot $LGAD_A_pos $LGAD_A_rot 1
    #CALL @PRINT_SURVEY_RESULTS $topB_pos $topB_rot $LGAD_B_pos $LGAD_B_rot 2
    #CALL @PRINT_SURVEY_RESULTS $topC_pos $topC_rot $LGAD_C_pos $LGAD_C_rot 3
    #CALL @PRINT_SURVEY_RESULTS $topD_pos $topD_rot $LGAD_D_pos $LGAD_D_rot 4

    #Puts relative alignment of subassemblies in gantry coordinates using Module PCB position
    TRANSFORML2G $bot_pos_A {-11.0,-11.05,0}  $bot_pos $bot_rot       
    TRANSFORML2G $bot_pos_B {11.0,-11.05,0} $bot_pos $bot_rot
    TRANSFORML2G $bot_pos_C {-11.0,11.05,0}   $bot_pos $bot_rot
    TRANSFORML2G $bot_pos_D {11.0,11.05,0}  $bot_pos $bot_rot

    #PICK AND PLACE ALL SUB ASSEMBLIES ONTO MODULE PCB
    LOADTOOL etl_picker_tool
    #THIS IS NOT CORRECT GENERALLY! COULD GO OVER OR UNDER, CREATE SIGN FUCNTION TO FIX
    ADD $topA_rot $topA_rot -180 #since it is rotated -180 deg on staging area
    ADD $topB_rot $topB_rot -180 #need to rotate it back 

    PICKPART $topA_pos $topA_rot "etl_chuck_{$top_chuck_num}_pos_{$topA_pos_num}" etl_chuck_4
    PLACEPART $bot_pos_A $topB_rot "" etl_chuck_{$bot_chuck_num}
    PICKPART $topB_pos $bot_rot_A "etl_chuck_{$top_chuck_num}_pos_{$topB_pos_num}" etl_chuck_4
    PLACEPART $bot_pos_B $bot_rot_B "" etl_chuck_{$bot_chuck_num}
    PICKPART $topC_pos $topC_rot "etl_chuck_{$top_chuck_num}_pos_{$topC_pos_num}" etl_chuck_4
    PLACEPART $bot_pos_C $bot_rot_C "" etl_chuck_{$bot_chuck_num}
    PICKPART $topD_pos $topD_rot "etl_chuck_{$top_chuck_num}_pos_{$topD_pos_num}" etl_chuck_4
    PLACEPART $bot_pos_D $bot_rot_D "" etl_chuck_{$bot_chuck_num}
    UNLOADTOOL

    GOTOIF @NOPRINT $print_results
    MOVENAME "etl_chuck_{$bot_chuck_num}"
    CALL @SURVEY_CORRECTED $bot_chuck_num $bot_pos_A $bot_rot_A 1 0 -> $pos_corr_A $rot_corr_A
    CALL @PRINT_SURVEY_RESULTS $bot_pos_A $bot_rot_A $pos_corr_A $rot_corr_A 1

    CALL @SURVEY_CORRECTED $bot_chuck_num $bot_pos_B $bot_rot_B 1 0 -> $pos_corr_B $rot_corr_B
    CALL @PRINT_SURVEY_RESULTS $bot_pos_B $bot_rot_B $pos_corr_B $rot_corr_B 2

    CALL @SURVEY_CORRECTED $bot_chuck_num $bot_pos_C $bot_rot_C 1 0 -> $pos_corr_C $rot_corr_C
    CALL @PRINT_SURVEY_RESULTS $bot_pos_C $bot_rot_C $pos_corr_C $rot_corr_C 3

    CALL @SURVEY_CORRECTED $bot_chuck_num $bot_pos_D $bot_rot_D 1 0 -> $pos_corr_D $rot_corr_D
    CALL @PRINT_SURVEY_RESULTS $bot_pos_D $bot_rot_D $pos_corr_D $rot_corr_D 4
    @NOPRINT
    RETURN

@PRINT_SURVEY_RESULTS(target_pos,target_rot,meas_pos,meas_rot,chip_num)
    PRINT "CHIP %d:" $chip_num
    PRINT "    target: %v | %f deg" $target_pos $target_rot
    PRINT "    actual: %v | %f deg" $meas_pos $meas_rot
    SUB $pos_err $meas_pos $target_pos
    SUB $rot_err $meas_rot $target_rot
    PRINT "    delta:  %v | %f deg" $pos_err $rot_err
    RETURN

@SURVEY_CORRECTED(chuck_num,target_pos,target_rot,piece)
# Arguments:
    #  $chuck_num - 
    #  $pos - 
    #  $rot -
    #  $piece -

    FLEXREAD $tr_local geometry.ETL_Sensor_PCB_Mockup.fid_tr  
    FLEXREAD $tl_local geometry.ETL_Sensor_PCB_Mockup.fid_tl
    FLEXREAD $bl_local geometry.ETL_Sensor_PCB_Mockup.fid_bl
    FLEXREAD $br_local geometry.ETL_Sensor_PCB_Mockup.fid_br 
    
    TRANSFORML2G $tr_global $tr_local $target_pos $target_rot
    TRANSFORML2G $tl_global $tl_local $target_pos $target_rot
    TRANSFORML2G $bl_global $bl_local $target_pos $target_rot
    TRANSFORML2G $br_global $br_local $target_pos $target_rot

    #this is to get corrected centers and orientation, the code above gives general area
    #MOVENAME "etl_chuck_{$chuck_num}"
    #Routine to set up inital position of metal piece
    COPY $tr 1
    COPY $br 2
    COPY $bl 3
    COPY $tl 4
    CALL @ACQUIREFIDUCIAL $tl_global $piece $tl -> $tl_corrected
    CALL @ACQUIREFIDUCIAL $tr_global $piece $tr -> $tr_corrected
    CALL @ACQUIREFIDUCIAL $bl_global $piece $bl -> $bl_corrected
    CALL @ACQUIREFIDUCIAL $br_global $piece $br -> $br_corrected

	   FIT $pos $rot ETL_Sensor_PCB_Mockup $tr_corrected $br_corrected $bl_corrected $tl_corrected
    QUAT2EULER $phi $_ $_ $rot
    RETURN $pos $phi


@SURVEY_PART(chuck_num,pos_num,piece,is_top)
    # Arguments:
    #  $chuck_num - 
    #  $pos_num - 
	   #  $is_top - 1 for survey position of top, 0 for bottom
	
    SETLIGHT 40
	
	   GOTOIF @LOAD_TOP_DATA $is_top
    FLEXREAD $tr_local geometry.ETL_mock_base.fid_tr  
    FLEXREAD $tl_local geometry.ETL_mock_base.fid_tl
    FLEXREAD $bl_local geometry.ETL_mock_base.fid_bl
    FLEXREAD $br_local geometry.ETL_mock_base.fid_br

    FLEXREAD $pos_default "default.ETL_mock_base.{$chuck_num}.{$pos_num}.pos"
    FLEXREAD $rot_default "default.ETL_mock_base.{$chuck_num}.{$pos_num}.rot"
    GOTO @END_LOAD
	
	   @LOAD_TOP_DATA
    FLEXREAD $tr_local geometry.ETL_Sensor_PCB_Mockup.fid_tr  
    FLEXREAD $tl_local geometry.ETL_Sensor_PCB_Mockup.fid_tl
    FLEXREAD $bl_local geometry.ETL_Sensor_PCB_Mockup.fid_bl
    FLEXREAD $br_local geometry.ETL_Sensor_PCB_Mockup.fid_br

    FLEXREAD $pos_default "default.ETL_Sensor_PCB_Mockup.{$chuck_num}.{$pos_num}.pos"
    FLEXREAD $rot_default "default.ETL_Sensor_PCB_Mockup.{$chuck_num}.{$pos_num}.rot"
    @END_LOAD
	
    #converts the local coordinates to global gantry coordinates usint start location and orientation
    TRANSFORML2G $tr_global $tr_local $pos_default $rot_default
    TRANSFORML2G $tl_global $tl_local $pos_default $rot_default
    TRANSFORML2G $bl_global $bl_local $pos_default $rot_default
    TRANSFORML2G $br_global $br_local $pos_default $rot_default

    #this is to get corrected centers and orientation, the code above gives general area
    #MOVENAME "etl_chuck_{$chuck_num}"
    #Routine to set up inital position of metal piece

    COPY $tr 1
    COPY $br 2
    COPY $bl 3
    COPY $tl 4
    CALL @ACQUIREFIDUCIAL $tl_global $piece $tl -> $tl_corrected
    CALL @ACQUIREFIDUCIAL $tr_global $piece $tr -> $tr_corrected
    CALL @ACQUIREFIDUCIAL $bl_global $piece $bl -> $bl_corrected
    CALL @ACQUIREFIDUCIAL $br_global $piece $br -> $br_corrected

    # Turns measured corners or fiducials into center and orientation
	   GOTOIFN @FIT_TOP $is_top
    FIT $pos $rot ETL_Sensor_PCB_Mockup $tr_corrected $br_corrected $bl_corrected $tl_corrected
    GOTO @FINISH_SURVEY
	   @FIT_TOP
	   FIT $pos $rot ETL_mock_base $tr_corrected $br_corrected $bl_corrected $tl_corrected
    @FINISH_SURVEY
    QUAT2EULER $phi $_ $_ $rot
    RETURN $pos $phi

@SURVEY_LGAD(chuck_num,pos_num,piece)
    # Arguments:
    #  $chuck_num - 
    #  $pos_num - 
	
    SETLIGHT 40
	
    FLEXREAD $tr_local geometry.ETL_LGAD_Mockup.fid_tr  
    FLEXREAD $tl_local geometry.ETL_LGAD_Mockup.fid_tl
    FLEXREAD $bl_local geometry.ETL_LGAD_Mockup.fid_bl
    FLEXREAD $br_local geometry.ETL_LGAD_Mockup.fid_br

    FLEXREAD $pos_default "default.ETL_LGAD_Mockup.{$chuck_num}.{$pos_num}.pos"
    FLEXREAD $rot_default "default.ETL_LGAD_Mockup.{$chuck_num}.{$pos_num}.rot"
	
    #converts the local coordinates to global gantry coordinates usint start location and orientation
    TRANSFORML2G $tr_global $tr_local $pos_default $rot_default
    TRANSFORML2G $tl_global $tl_local $pos_default $rot_default
    TRANSFORML2G $bl_global $bl_local $pos_default $rot_default
    TRANSFORML2G $br_global $br_local $pos_default $rot_default

    #this is to get corrected centers and orientation, the code above gives general area
    #MOVENAME "etl_chuck_{$chuck_num}"
    #Routine to set up inital position of metal piece

    COPY $tr 1
    COPY $br 2
    COPY $bl 3
    COPY $tl 4
    CALL @ACQUIREFIDUCIAL $tl_global $piece $tl -> $tl_corrected
    CALL @ACQUIREFIDUCIAL $tr_global $piece $tr -> $tr_corrected
    CALL @ACQUIREFIDUCIAL $bl_global $piece $bl -> $bl_corrected
    CALL @ACQUIREFIDUCIAL $br_global $piece $br -> $br_corrected

    # Turns measured corners or fiducials into center and orientation
    FIT $pos $rot ETL_LGAD_Mockup $tr_corrected $br_corrected $bl_corrected $tl_corrected
    QUAT2EULER $phi $_ $_ $rot
    RETURN $pos $phi

@ACQUIREFIDUCIAL(start_pos,piece,loc)
    # Arguments:
    #  $start_pos - Position to initially search for the fiducial
	   #  $piece - PCB or ETROC, 1 or 2 respectively
    #  $loc - tr == 1, br == 2, bl == 3, tl == 4
    MOVETO $start_pos 50
    WAIT 100

    # GOTO @manual_fiducial_acquisition

    SETERRORMODE setvar
    FINDFID $fid_position etl_throughput_etroc
    GOTOIF @manual_fiducial_acquisition $ERR
    SETERRORMODE default
    RETURN $fid_position
    
    @manual_fiducial_acquisition
    SETERRORMODE default
    VIDEO
    getpos $fid_position
    RETURN $fid_position